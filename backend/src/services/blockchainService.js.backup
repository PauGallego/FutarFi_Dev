const { ethers } = require('ethers');
const contractLoader = require('../config/contractLoader');
const Proposal = require('../models/Proposal');

class BlockchainService {
  constructor() {
    this.provider = null;
    this.proposalManagerContract = null;
    this.isInitialized = false;
  }

  async  // Start price monitoring and proposal checking every 5 seconds
  startPriceMonitoring() {
    console.log('ÔøΩ Starting price monitoring and proposal checking (every 5 seconds)...');
    
    setInterval(async () => {
      await this.checkForNewProposals();
      await this.updateProposalPrices();
    }, 5000); // 5 seconds
  }

  async checkForNewProposals() {
    if (!this.isInitialized) return;
    
    try {
      // Get all proposal addresses from blockchain
      const proposalAddresses = await this.proposalManagerContract.getAllProposals();
      
      // Get current proposals from database
      const existingProposals = await Proposal.find({}).select('contractAddress');
      const existingAddresses = existingProposals.map(p => p.contractAddress.toLowerCase());
      
      // Find new proposals (on blockchain but not in database)
      const newProposals = proposalAddresses.filter(address => 
        !existingAddresses.includes(address.toLowerCase())
      );
      
      if (newProposals.length > 0) {
        console.log(`üÜï Found ${newProposals.length} new proposals!`);
        
        for (const address of newProposals) {
          try {
            await this.saveProposal(address);
            console.log(`‚úÖ New proposal automatically saved: ${address}`);
          } catch (error) {
            console.error(`‚ùå Error saving new proposal ${address}:`, error);
          }
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error checking for new proposals:', error);
    }
  }ize() {
    try {
      console.log('üöÄ Initializing Blockchain Service...');
      
      // Connect to blockchain
      const rpcUrl = process.env.RPC_URL || 'http://localhost:8545';
      this.provider = new ethers.JsonRpcProvider(rpcUrl);
      console.log('üîó Connected to blockchain:', rpcUrl);
      
      // Load contract addresses
      contractLoader.loadAddresses();
      const proposalManagerAddress = contractLoader.getProposalManagerAddress();
      
      if (!proposalManagerAddress) {
        throw new Error('ProposalManager address not found');
      }
      
      // Create contract instance
      this.proposalManagerContract = new ethers.Contract(
        proposalManagerAddress,
        this.getProposalManagerABI(),
        this.provider
      );
      
      console.log('ÔøΩ ProposalManager loaded:', proposalManagerAddress);
      
      // Setup event listeners for new proposals
      this.setupEventListeners();
      
      // Import existing proposals
      await this.importExistingProposals();
      
      this.isInitialized = true;
      console.log('‚úÖ Blockchain Service initialized successfully');
      
    } catch (error) {
      console.error('‚ùå Error initializing blockchain service:', error);
      throw error;
    }
  }

  setupEventListeners() {
    console.log('üéß Setting up event listeners...');
    
    this.proposalManagerContract.on('ProposalCreated', async (proposalId, admin, proposalAddress, event) => {
      console.log(`üÜï New proposal detected: ID=${proposalId}, Admin=${admin}, Address=${proposalAddress}`);
      
      try {
        await this.saveProposal(proposalAddress);
        console.log(`‚úÖ New proposal saved: ${proposalAddress}`);
      } catch (error) {
        console.error(`‚ùå Error saving new proposal ${proposalAddress}:`, error);
      }
    });
  }

  async importExistingProposals() {
    console.log('ÔøΩ Importing existing proposals...');
    
    try {
      // Get all proposal addresses from blockchain
      const proposalAddresses = await this.proposalManagerContract.getAllProposals();
      console.log(`üìã Found ${proposalAddresses.length} proposals on blockchain`);
      
      if (proposalAddresses.length === 0) {
        console.log('üìã No proposals to import');
        return;
      }
      
      // Process each proposal
      for (let i = 0; i < proposalAddresses.length; i++) {
        const address = proposalAddresses[i];
        console.log(`üìã Processing proposal ${i + 1}/${proposalAddresses.length}: ${address}`);
        
        try {
          await this.saveProposal(address);
          console.log(`‚úÖ Imported proposal: ${address}`);
        } catch (error) {
          console.error(`‚ùå Error importing proposal ${address}:`, error);
        }
      }
      
      console.log('‚úÖ Finished importing existing proposals');
    } catch (error) {
      console.error('‚ùå Error importing existing proposals:', error);
    }
  }

  async saveProposal(proposalAddress) {
    try {
      // Check if proposal already exists in database
      const existingProposal = await Proposal.findOne({ contractAddress: proposalAddress.toLowerCase() });
      if (existingProposal) {
        console.log(`üìã Proposal ${proposalAddress} already exists in database`);
        return existingProposal;
      }
      
      // Get proposal details from blockchain
      const proposalData = await this.getProposalData(proposalAddress);
      
      // Save to database
      const proposal = new Proposal(proposalData);
      await proposal.save();
      
      console.log(`üíæ Saved proposal to database: ${proposalData.name}`);
      return proposal;
      
    } catch (error) {
      console.error(`‚ùå Error saving proposal ${proposalAddress}:`, error);
      throw error;
    }
  }

  async getProposalData(proposalAddress) {
    try {
      console.log(`üîç Getting details for proposal: ${proposalAddress}`);
      
      // Create proposal contract instance
      const proposalContract = new ethers.Contract(
        proposalAddress,
        this.getProposalABI(),
        this.provider
      );
      
      // Get basic proposal data
      const [id, name, description, admin, startTime, endTime, marketAddress, isActive] = await Promise.all([
        proposalContract.id(),
        proposalContract.name(), 
        proposalContract.description(),
        proposalContract.admin(),
        proposalContract.startTime(),
        proposalContract.endTime(),
        proposalContract.market(),
        proposalContract.isActive()
      ]);
      
      console.log(`üìã Proposal basic data: ${name} (ID: ${id}), Active: ${isActive}`);
      
      // Get market data
      const marketContract = new ethers.Contract(
        marketAddress,
        this.getMarketABI(),
        this.provider
      );
      
      const [approveToken, rejectToken, isMarketOpen] = await Promise.all([
        marketContract.approveToken(),
        marketContract.rejectToken(),
        marketContract.isOpen()
      ]);
      
      // Get current prices
      const [approvePrice, rejectPrice] = await Promise.all([
        marketContract.getMarketTypePrice(0), // Approve token price
        marketContract.getMarketTypePrice(1)  // Reject token price
      ]);
      
      console.log(`üí∞ Initial prices - Approve: ${approvePrice}, Reject: ${rejectPrice}`);
      
      // Determine status based on proposal state
      let status = 'active';
      if (!isActive) {
        status = 'ended';
      }
      
      return {
        proposalId: parseInt(id),
        name: name,
        description: description,
        admin: admin.toLowerCase(),
        contractAddress: proposalAddress.toLowerCase(),
        marketAddress: marketAddress.toLowerCase(),
        approveTokenAddress: approveToken.toLowerCase(),
        rejectTokenAddress: rejectToken.toLowerCase(),
        startTime: new Date(parseInt(startTime) * 1000),
        endTime: new Date(parseInt(endTime) * 1000),
        status: status,
        currentApprovePrice: approvePrice.toString(),
        currentRejectPrice: rejectPrice.toString(),
        createdAt: new Date()
      };
      
    } catch (error) {
      console.error(`‚ùå Error getting proposal data for ${proposalAddress}:`, error);
      throw error;
    }
  }

  async updateProposalPrices() {
    if (!this.isInitialized) return;
    
    try {
      // Get all active proposals from database
      const proposals = await Proposal.find({ status: 'active' });
      
      if (proposals.length === 0) return;
      
      console.log(`üìä Updating prices for ${proposals.length} proposals...`);
      
      for (const proposal of proposals) {
        try {
          await this.updateSingleProposalPrice(proposal);
        } catch (error) {
          console.error(`‚ùå Error updating prices for proposal ${proposal.contractAddress}:`, error);
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error in price update cycle:', error);
    }
  }

  async updateSingleProposalPrice(proposal) {
    try {
      // Create proposal contract instance to check if still active
      const proposalContract = new ethers.Contract(
        proposal.contractAddress,
        this.getProposalABI(),
        this.provider
      );
      
      const isActive = await proposalContract.isActive();
      
      // Update status if proposal is no longer active
      if (!isActive && proposal.status === 'active') {
        proposal.status = 'ended';
        await proposal.save();
        console.log(`üìã Proposal ${proposal.name} marked as ended`);
        return; // Don't update prices for ended proposals
      }
      
      // Only update prices for active proposals
      if (proposal.status !== 'active') {
        return;
      }
      
      // Create market contract instance
      const marketContract = new ethers.Contract(
        proposal.marketAddress,
        this.getMarketABI(),
        this.provider
      );
      
      // Check if market is still open
      const isMarketOpen = await marketContract.isOpen();
      if (!isMarketOpen) {
        console.log(`üìã Market for proposal ${proposal.name} is closed`);
        return;
      }
      
      // Get current prices
      const [newApprovePrice, newRejectPrice] = await Promise.all([
        marketContract.getMarketTypePrice(0),
        marketContract.getMarketTypePrice(1)
      ]);
      
      const newApprovePriceStr = newApprovePrice.toString();
      const newRejectPriceStr = newRejectPrice.toString();
      
      // Check if prices changed
      const pricesChanged = 
        newApprovePriceStr !== proposal.currentApprovePrice || 
        newRejectPriceStr !== proposal.currentRejectPrice;
      
      if (pricesChanged) {
        console.log(`üí∞ Price change detected for ${proposal.name}:`);
        console.log(`   Approve: ${proposal.currentApprovePrice} ‚Üí ${newApprovePriceStr}`);
        console.log(`   Reject: ${proposal.currentRejectPrice} ‚Üí ${newRejectPriceStr}`);
        
        // Update proposal with new prices
        proposal.currentApprovePrice = newApprovePriceStr;
        proposal.currentRejectPrice = newRejectPriceStr;
        proposal.updatedAt = new Date();
        
        // Add price history entry
        proposal.priceHistory.push({
          timestamp: new Date(),
          approvePrice: newApprovePriceStr,
          rejectPrice: newRejectPriceStr
        });
        
        await proposal.save();
        
        console.log(`üíæ Updated prices for proposal: ${proposal.name}`);
      }
      
    } catch (error) {
      console.error(`‚ùå Error updating price for proposal ${proposal.contractAddress}:`, error);
    }
  }

  // Start price monitoring every 5 seconds
  startPriceMonitoring() {
    console.log('ÔøΩ Starting price monitoring (every 5 seconds)...');
    
    setInterval(async () => {
      await this.updateProposalPrices();
    }, 5000); // 5 seconds
  }

  getProposalManagerABI() {
    return [
      "event ProposalCreated(uint256 indexed proposalId, address indexed admin, address indexed proposal)",
      "function getAllProposals() external view returns (address[] memory)"
    ];
  }

  getProposalABI() {
    return [
      "function id() external view returns (uint256)",
      "function name() external view returns (string memory)",
      "function description() external view returns (string memory)",
      "function admin() external view returns (address)",
      "function startTime() external view returns (uint256)",
      "function endTime() external view returns (uint256)",
      "function market() external view returns (address)",
      "function isActive() external view returns (bool)"
    ];
  }

  getMarketABI() {
    return [
      "function approveToken() external view returns (address)",
      "function rejectToken() external view returns (address)",
      "function getMarketTypePrice(uint8 idx) external view returns (uint256)",
      "function isOpen() external view returns (bool)",
      "function totalSupply() external view returns (uint256 tot0, uint256 tot1)",
      "function totalCollateralSupply() external view returns (uint256 tot0, uint256 tot1)"
    ];
  }
}

module.exports = new BlockchainService();


